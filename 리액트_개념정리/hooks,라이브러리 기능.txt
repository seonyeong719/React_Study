- useState
    * 장점 => 함수형 컴포넌트에서 상탯값을 관리하게 해준다. 

    * 단점 => 랜더링이 되기 때문에 너무 남발 할 경우 state 관리에 좋지 않다.

- useEffect
    * 장점 => useEffect는 반드시 컴포넌트가 모두 렌더링 되고 화면에 다 그려진 후에 호출이 된다.
             장점은 컴포넌트가 중간에 useEffect에 의해서 영향을 받아 모양이 바뀌는것을 방지해준다.

    * 단점 => side effects 수행을 처리하기 위해 useEffect를 사용하는데, 
             이는 아직 완벽하지 않다. 

- useReducer
    * 장점 => 비즈니스 로직이 분리가 되어있어서 재사용이 용이하다. (즉, 전역상태관리에 좋다.)
		    state 변경로직을 반복적으로 사용해야할때 사용 용이. (flux패턴 기반.)
		    복잡한 state의 변경 로직 ( 함수 )를 바깥으로 빼내어 dispatch를 통해 
            해당 로직은 어디에서나 재사용할 수 있도록 하기 위해 사용한다.

    * 단점 => 반복되지도 않는 로직을 빼서 사용하면 코드가 길어지고, 개발자에게 어떤 타입을 보내야하는지 혼동을준다는 단점이 있다. 


- useContext
    * 장점 => 전역상태관리에 용이. 프롭스 드릴링(props drilling) 없이 바로 전역으로 관리할 수 있는점이 장점. 
            (쉽게 말해!! 우산을 만든다~ 라고 생각 하면 되는데, 그 우산을 씌워주고 싶은 컴포넌트들의 부모에 선언해주면 
              그 우산을 쓰고 있는 모든 하위 컴포넌트, 자식 요소들이 그 우산에 있는 데이터에 접근이 가능하다.)  

    * 단점 => context 로 묶여진? 사용되는 state들을 다 재랜더링 시켜서 context는 남발 하면 안된다. 
            (부모가 랜더링 되면 해당 자식 컴포넌트들까지 다 랜더링 시킨다는 소리.)
             (기능을 생각하고 필요한 컴포넌트에 만들어서 사용하자~)


- useMemo
    * 장점 => 이미 연산된 값을 메모해둠으로서 재사용하는 hook이다.
             복잡한 계산이 포함된 함수인 경우 매번 새로 값을 계산하게 되면 불필요한 연산이 수행되는데 useMemo()를 사용하게 되면, 
             값이 변경되지 않는 이상 반복되는 렌더링시에 다시 계산할 필요 없이 값을 사용할 수 있다.
             즉 useMemo는 값에 리렌더링을 막기 위해서 메모이제이션된 값을 반환하는 것.
             
             
    * 단점 => 코드가 늘어난다는 비용적인 측면에서 추천하지 않는다.

 
어느때 사용해야 메모아이제이션

- useCallback
    * 장점 => useMemo가 계산된 값을 재사용한다면 useCallback은 계산된 함수!!를 기억하고 재사용한다.
             useMemo와 동일하게, 컴포넌트의 랜더링이 일어나게 되면 그 안에 있는 함수까지 다시 랜더링이 일어나게 된다.
             그렇기 때문에 호출되지 않은 함수에 대해서는 계산의 낭비가 없도록 useCallback을 사용하면 좋다.
             useCallback은 useMemo와 동일하게 최적화를 위한 Hook이고 용법이 크게 다르지않다. 
             즉 리렌더링을 방지하기 위해 메모이제이션된 콜백 함수를 반환하는 것이다.

             
    * 단점 => 컴포넌트가 렌더링 될 때 마다 콜백함수를 새로 생성한다는 단점이 있다.


===================================================================================


- 커스텀 훅
    * 함수로 선언해주고 , 안에 훅함수 사용 가능. 리턴으로는 사용하고 싶은 데이터를 바로 사용 가능. 
        컴포넌트를 잘 만들기 위해서는 커스텀훅을 잘 만들어야한다. 
        컴포넌트에서 데이터를 다루는 부분이 복잡해지게 되면 항상 커스텀훅으로 뺄 수 있는지 생각해보는게 좋다.
    *** hooks은(함수들은) 코드의 재사용(로직의 재사용)이지, 값의 재사용이 아니다. 아주 중요!!!! 





- Immer (이머)

    중첩된 객체가 많아지고 스프레드 연산자를 계속 해서 반복적으로 사용하는것이 복잡하여
    좀 더 직관적으로 사용하고 싶다고 생각한 사람들이 만든게 이머(immer)라이브러리 이다. 

    * 동작 원리?
        일반 object를 만들어 주는 것 처럼 사용을 하지만, immer 내부적으로 별도의 객체를 만들어서
        우리가 원하는것을 수정 하면? =>  immer에서 내부적으로 새로운 객체를 만들어서 필요한것만 업데이트 해서 새로운 객체를 만들어 준다. 


