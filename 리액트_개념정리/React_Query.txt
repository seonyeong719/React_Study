React Query (리액트 쿼리)

*리액트 쿼리를 쓰는 이유?
    - Hook의 문제는 캐시(cache)가 되지 않는다.
        네트워크에서 받아온 데이터를 별도로 저장해두는것이 아니라 이 훅을 호출할때마다 계속 새롭게 데이터를 받아올것이다.

         훅은 로딩중인지 에러가 발생했는지의 데이터는 들어있지만 아직 구현해두지 않아서 리트라이(retry) 기능이 없다. 
         그래서 이 네트워크 통신이 실패했을 경우 재시도할 수 있는 부분이 결여되어 있다. 
        

        ** 리액트 쿼리는 이런 문제를 해결해준다~
         네트워크 통신도 간편하게 할수있게 해주고 로딩중인지 에러가 발생했는지, 데이터를 받아왔는지, 손쉽게 알 수 있다. 
         또한 여러 컴포넌트에 걸쳐서 똑같은 데이터를 네트워크에 요청하는것이 아니라 
         동일한 네트워크 요청이라면 얼마동안 내가 우리 어플리케이션에 메모리상에 캐시를 해둘건지
         이 캐시 시스템을 제공해주고 글로벌 상태관리도 제공해주고, 네트워크 요청이 실패했다면 조금 이따가 다시 시동해보는 재시도 기능도 들어있다. 

        네트워크 통신이나 또는 비동기 적으로 데이터를 관리해야 할 경우 유용하게 사용할수 있는거싱 바로 리액트 쿼리(React-Query) 이다.


TanStack Query 
    - 이점? => 강력한 비동기 상태 관리 라이브러리이다.
        TS, JS, React, Solid ,Vue, Svelte 다 사용 가능 




    사용법(+순서)?
        - TanStack 공식 홈페이지에 가서 npm 다운로드를 한다.
        - 그러고 App.js로 가서 우산을 씌어 줄건데, 
        QueryClient, QueryClientProvider 를 import 해준다. 

        => const queryClient = new QueryClient(); 를 만들어 주고 

        - return() 안에다가 ~
            <QueryClientProvider client={queryClient}>
                <anything/>
            </QueryClientProvider>

            => 이런식으로 감싸준다. 이렇게 쿼리클라이언트를 사용하도록 어플리케이션 전체적으로 우산을 씌어준다음,
            내가 필요한 컴포넌트에서 useQuery를 사용하기만 하면 된다.

            어디서 데이터를 가지고 올건지 알려주면 로딩중인지,에러가 발생했는지,데이터가 있는지 알려주고, 
            내부적으로 캐싱을 해준다고 한다. (=cache도 해준다.)

        - 네트워크 통신을 할 컴포넌트로 가서 useQuery를 import 해준다.
        - 컴포넌트 안에 ~ ex)
            const {isLoading, error, data} = useQuery(
                ['anything'],() => getDetail({ movieId }),
            {
                refetchOnWindowFocus: false,
                retry: 0,
            },)
            /*
            1. 객체에는 구조분해 할당으로 관심있는것만 변수로 할당 해줄것이다. 
            2. 첫번째 인자에 키를 전달해주어야 하는데, 키는 항상 고유한 값을 써야 한다.=>['anything']
            (useEffect에서 디펜던시를 배열로 전달해준 것처럼 여기서도 배열로 디펜던시를 전달해준다.)
                ** 쿼리를 사용하면 우리가 키를 제공해주는데 네트워크 통신별로 각각 고유한 키를 제공해줌 
                키 이름 아래에 데이터를 메모리로 보관해둔다. 
                그래서 다른 컴포넌트에서 동일한 키를 사용한다면 해당 키에 저장된 메모리가 있으니 이미 저장된 데이터를 전달해줌.
                캐시된 데이터를 전달해주기 때문에 네트워크 통신을 한번만 해도 가능하다. 
            */ 



Query Keys

    - 리액트 쿼리는 key 에 의존해서 데이터를 관리한다. 
      그래서 캐싱을 적절히 잘 활용하려면 고유한 키를 잘 사용해야 한다.(잘 명시할것.)
    
    - 왜 문자열이 아니고 배열인가?
        우리가 조금 더 세밀하게 키들의 조합을 만들어 나갈 수 있다.
        ex) * useQuery(['todo'...]) 
            * useEffect에서(['anything'],['something'], ...)
            
            ~ 이렇게 하나가 아닌 두개도 쓸 수 있는데, 우리가 원하는 조건별로, 세부 상태별로 
            키를 할당해주면 원하는 데이터를 조합해서 갖다 쓸 수 있다. 



** Important Defaults **

    리액트 쿼리를 사용 할 때 꼭 명심해야 할 것!!!!!!!!!

        useQuery는 useQuery,useInfiniteQuery 를 사용 할 수 있는데,
        기본적으로 이 두개를 사용하면 캐시된 데이터는 stale이라고 간주한다. (stale = 신선하지 않은)

        이 기본적인 행동을 변경하기 위해서는 쿼리를 쓸 때 글로벌로 설정하거나 각 쿼리별로 staleTime 이라는 옵션을 설정해주면 된다.
        한번 네트워크에서 받아온 데이터를 얼마동안 신선하다고 간주할건지 설정해주면 된다. 

            신선하다는건?
                - 동일한 네트워크를 불러올때 신선하니까 캐시된 데이터를 쓴다. 또다시 네크워크 요청을 하는게 아니라.

            그래서 stale이 붙은 쿼리들을 자동적으로 refetch 되게 한다. (계속 네트워크 통신을 한다.)
            
            언제?
            * 새로운 쿼리가 만들어졌을 때.
            * 윈도우가 자동으로 포커스가 됐을 때.
            * 네트워크가 다시 연결 됐을 때.
            * 쿼리가 다시 refetch Interval이 설정 되었을 때. (몇초 간격으로 계속 리패치를 하라고 설정이 되었을때) 



      



